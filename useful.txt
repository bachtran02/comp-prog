// TEMPLATE
// LINEAR SIEVE:

const int nn = 1e6;
int lp[nn+1];
vector<int> sieve(){
	vector<int> pr;
	for (int i=2; i<=nn; ++i) {
		if (lp[i] == 0) {
			lp[i] = i;
			pr.push_back (i);
		}
		for (int j=0; j<(int)pr.size() && pr[j]<=lp[i] && i*pr[j]<=nn; ++j)
			lp[i * pr[j]] = pr[j];
	}
	return pr;
}

// bool prime sieve
vector<bool> prime(n+1, true);
prime[0] = false, prime[1] = false;
for(int i = 2; i*i <= n; i++){
	if(prime[i]){
		for(int j = i*i; j <= n; j+=i){
			prime[j] = false;
		}
	}
}

// factorize
map<long long,int> factorize(long long num){
    map<long long,int> factors;
    for(long long i = 2; i * i <= num; i++){
        while(num % i == 0){
            num /= i;
            factors[i]++;
        }
    }
    if(num != 1ll) factors[num]++;
    return factors;
}


// euclidean GCD
int gcd(int a, int b){
	if(b == 0) return a;
	return gcd(b, a%b);
}

int gcd(int a, int b){
	int R;
	while( (a % b) > 0 ){
		R = a % b;
		a = b;
		b = R;
	}
	return b;
}

// factmod
const int mod = 1e9;
int factmod(int n) {
    int p = mod;
    vector<int> f(p);
    f[0] = 1;
    for (int i = 1; i < p; i++)
        f[i] = f[i-1] * i % p;

    int res = 1;
    while (n > 1) {
        if ((n/p) % 2)
            res = p - res;
        res = res * f[n%p] % p;
        n /= p;
    }
    return res; 
}

// ncr
int nCr(int n, int r){
    if(r>n) return 0;
    return factmod(n) / (factmod(r)*factmod(n-r));
}
// npr
int nPr(int n, int r){
	if(r>n) return 0;
	return factmod(n) / factmod(n-r);
}
// ncr2
int nCr(int n, int r){
	if(r>n) return 0;
	long long ans = 1;
	for(int i = 1; i <= r; i++){
		ans *= n-i;
		ans /= i;
	}
	return ans;
}

// mod add
void add(int& a, int b){
    a+=b;
    if(a>=mod){
        a-=mod;
    }
}

// pow mod karatsuba
long long modpow(long long base, long long exp) {
	base %= MOD;
	long long result = 1;
	while (exp > 0) {
		if (exp & 1) result = (result * base) % MOD;
		base = (base * base) % MOD;
		exp >>= 1;
	}
	return result;
}

// HASH
struct custom_hash {
    size_t operator()(uint64_t x) const {
        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();
        x ^= FIXED_RANDOM;
        return x ^ (x >> 16);
    }
template <class T1, class T2>
    std::size_t operator () (std::pair<T1, T2> const &pair) const {
        std::size_t h1 = std::hash<T1>()(pair.first);
        std::size_t h2 = std::hash<T2>()(pair.second);
        return h1 ^ h2;
    }
};

// pair hash
struct pair_hash {
    template <class T1, class T2>
    std::size_t operator () (std::pair<T1, T2> const &pair) const {
        std::size_t h1 = std::hash<T1>()(pair.first);
        std::size_t h2 = std::hash<T2>()(pair.second);
        return h1 ^ h2;
    }
};
